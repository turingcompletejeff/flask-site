# Migrations Directory Context

## Purpose
Database schema version control using Flask-Migrate (Alembic). Contains migration scripts that track all database schema changes over time.

## Directory Structure
```
migrations/
├── alembic.ini       - Alembic configuration
├── env.py            - Migration environment setup
├── script.py.mako    - Template for new migrations
├── README            - Migration system overview
└── versions/         - Individual migration files (chronological)
```

## Migration Files (in versions/)

### Naming Convention
```
<revision_id>_<description>.py
Example: ba76cbd4fd71_add_is_draft_field_to_blogpost.py
```

### Existing Migrations
1. **1350aca454f1_init_migrate.py** - Initial database schema
   - Creates base tables: users, blog_posts, minecraft_commands
   - Initial model structure

2. **fb235ae0f99f_add_role_model_and_role_assignments_.py** - Role-based access control
   - Adds: roles table, role_assignments association table
   - Enables multi-role user permissions

3. **ba76cbd4fd71_add_is_draft_field_to_blogpost.py** - Draft functionality
   - Adds: is_draft boolean to blog_posts table
   - Default: True (new posts start as drafts)
   - Includes server_default for non-nullable field

4. **0197b862d1e3_tc_23_add_profile_picture_bio_and_.py** - User profiles
   - Adds: profile_picture, bio fields to users table
   - Enables user profile customization

## Migration File Structure

```python
"""Migration description

Revision ID: <auto-generated>
Revises: <previous_revision>
Create Date: <timestamp>
"""
from alembic import op
import sqlalchemy as sa

# Revision identifiers
revision = '<revision_id>'
down_revision = '<previous_revision>'
branch_labels = None
depends_on = None

def upgrade():
    """Apply schema changes"""
    op.add_column('table_name', sa.Column(...))
    # or
    op.create_table('table_name', ...)

def downgrade():
    """Revert schema changes"""
    op.drop_column('table_name', 'column_name')
    # or
    op.drop_table('table_name')
```

## Migration Commands

### Creating a New Migration
```bash
# Development
python manage.py db migrate -m "Description of changes"

# Docker
docker-compose exec flask-site flask db migrate -m "Description"
```

### Applying Migrations
```bash
# Development
python manage.py db upgrade

# Docker
docker-compose exec flask-site flask db upgrade
```

### Other Commands
```bash
flask db current           # Show current revision
flask db history           # Show migration history
flask db downgrade         # Rollback one migration
flask db downgrade <revision>  # Rollback to specific revision
flask db stamp head        # Mark database as up-to-date without running migrations
```

## Best Practices

### 1. Always Include server_default for Non-Nullable Columns
```python
# CORRECT
op.add_column('blog_posts',
    sa.Column('is_draft', sa.Boolean(),
              nullable=False,
              server_default='true'))

# INCORRECT (will fail on existing data)
op.add_column('blog_posts',
    sa.Column('is_draft', sa.Boolean(),
              nullable=False))
```

### 2. Test Migrations Before Committing
```bash
# Apply migration
flask db upgrade

# Verify database state
flask db current

# Test rollback
flask db downgrade
flask db upgrade

# Check for errors
docker-compose logs -f flask-site
```

### 3. Never Edit Existing Migrations
- Migrations are immutable once committed
- Create a new migration to fix issues
- Exception: Dev environment before first deployment

### 4. Keep Migrations Small and Focused
- One logical change per migration
- Clear, descriptive migration messages
- Easier to debug and rollback

### 5. Always Review Auto-Generated Migrations
Alembic detects model changes automatically, but verify:
- Correct column types
- Proper constraints (nullable, unique, etc.)
- Necessary indexes
- Foreign key relationships

## Common Migration Patterns

### Adding a Column
```python
def upgrade():
    op.add_column('users',
        sa.Column('new_field', sa.String(100),
                  nullable=True))

def downgrade():
    op.drop_column('users', 'new_field')
```

### Adding Non-Nullable Column with Default
```python
def upgrade():
    op.add_column('posts',
        sa.Column('status', sa.String(20),
                  nullable=False,
                  server_default='draft'))

def downgrade():
    op.drop_column('posts', 'status')
```

### Creating a New Table
```python
def upgrade():
    op.create_table('categories',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('name', sa.String(50), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.func.now()))

def downgrade():
    op.drop_table('categories')
```

### Adding Foreign Key
```python
def upgrade():
    op.add_column('posts',
        sa.Column('author_id', sa.Integer(), nullable=True))
    op.create_foreign_key(
        'fk_posts_author',
        'posts', 'users',
        ['author_id'], ['id'])

def downgrade():
    op.drop_constraint('fk_posts_author', 'posts', type_='foreignkey')
    op.drop_column('posts', 'author_id')
```

### Adding Index
```python
def upgrade():
    op.create_index('ix_users_email', 'users', ['email'])

def downgrade():
    op.drop_index('ix_users_email', 'users')
```

### Many-to-Many Association Table
```python
def upgrade():
    op.create_table('post_tags',
        sa.Column('post_id', sa.Integer(),
                  sa.ForeignKey('posts.id'), primary_key=True),
        sa.Column('tag_id', sa.Integer(),
                  sa.ForeignKey('tags.id'), primary_key=True))

def downgrade():
    op.drop_table('post_tags')
```

## Troubleshooting

### Migration Conflicts
**Problem**: Multiple developers create migrations from same base
**Solution**:
```bash
# Merge migrations
flask db merge <rev1> <rev2>
# Or rebase your migration
flask db downgrade
git pull
flask db migrate -m "Your changes"
```

### Migration Fails Midway
**Problem**: Error during upgrade(), database in inconsistent state
**Solution**:
```bash
# Manual intervention required
# 1. Check database state
# 2. Fix issue manually or via SQL
# 3. Mark migration as complete
flask db stamp head
# Or rollback and fix migration
flask db downgrade
# Edit migration file
flask db upgrade
```

### Alembic Can't Detect Changes
**Problem**: Model changed but `flask db migrate` finds nothing
**Possible causes**:
1. Changes not imported in models.py
2. Flask app not detecting model changes
3. Need to restart Flask app
**Solution**: Restart app, verify imports, manually create migration if needed

## Agent Touchpoints

### backend-architect
- Needs: Migration patterns, schema design, relationship patterns
- Common tasks: Planning database changes, designing migration strategy
- Key files: Existing migrations for patterns, env.py for configuration

### python-pro
- Needs: Migration script structure, Alembic API, upgrade/downgrade patterns
- Common tasks: Writing complex migrations, optimizing schema changes
- Key files: versions/*.py migration scripts

### security-auditor
- Needs: Migration security implications, data migration patterns
- Common tasks: Reviewing migrations for data exposure, validating constraints
- Key files: New migrations before deployment

### documentation-expert
- Needs: Migration history, schema evolution documentation
- Common tasks: Documenting schema changes, creating migration guides
- Key files: All migrations for changelog generation

## Database-Specific Considerations

### PostgreSQL Features Used
- `server_default=sa.func.now()` - Database-generated timestamps
- `ARRAY(db.String())` - PostgreSQL array columns
- Connection pooling settings from config.py

### Environment-Specific Migrations
Development vs Production:
- Development: Can reset migrations if needed
- Production: Migrations are irreversible, test thoroughly
- Use staging environment to test migrations before production

## Related Files
- `/app/models.py` - SQLAlchemy models that migrations are based on
- `/config.py` - Database connection settings
- `/manage.py` or flask CLI - Commands to run migrations (if manage.py exists)

## Migration Workflow

### Standard Workflow
1. **Modify model** in `/app/models.py`
2. **Generate migration**: `flask db migrate -m "Description"`
3. **Review migration** in `migrations/versions/`
4. **Edit if needed** (add server_defaults, etc.)
5. **Test upgrade**: `flask db upgrade`
6. **Test downgrade**: `flask db downgrade`
7. **Test upgrade again**: `flask db upgrade`
8. **Commit migration** with model changes

### Team Workflow
1. Pull latest code
2. Run `flask db upgrade` to apply teammates' migrations
3. Make your model changes
4. Generate and test your migration
5. Commit and push both model + migration
6. Communicate migration to team

## Important Notes

- **Never delete migrations** from version control
- **Always commit migrations** with corresponding model changes
- **Test rollback capability** before deploying to production
- **Include server_default** for non-nullable columns on existing tables
- **Review auto-generated migrations** - Alembic isn't perfect
- **Docker deployments**: Migrations run automatically on container startup (if configured)

## Emergency Procedures

### Reset Development Database
```bash
# WARNING: Destroys all data
flask db downgrade base
flask db upgrade
# Or drop/recreate database
docker-compose down -v
docker-compose up --build
```

### Fix Production Migration Issue
1. Never run untested migrations in production
2. Always have database backup before migrating
3. If migration fails, restore from backup
4. Fix migration offline, test in staging
5. Deploy fixed migration to production
